<!DOCTYPE html>
<html lang="en">
<head>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-ZHQBYJ36B9"></script>
    <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-ZHQBYJ36B9');
    </script>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hoo&nbsp;Hoo Studios</title>
    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600;700&display=swap" rel="stylesheet">
    <!-- Font Awesome for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" integrity="sha512-DTOQO9RWCH3ppGqcWaEA1BIZOC6xxalwEsw9c2QQeAIftl+Vegovlnee1c9QX4TctnWMn13TZye+giMm8e2LwA==" crossorigin="anonymous" referrerpolicy="no-referrer">
    <!-- Main stylesheet -->
    <link rel="stylesheet" href="style.css">
    <!-- Favicon -->
    <link rel="icon" type="image/png" href="img/owl.svg">
    <!-- Meta: Social / SEO -->
    <meta name="description" content="Hoo Hoo Studios â€” playful, atmospheric games crafted with care.">
    <meta property="og:title" content="Hoo Hoo Studios">
    <meta property="og:description" content="Playful, atmospheric games crafted with care.">
    <meta property="og:type" content="website">
    <meta property="og:image" content="img/space.jpg">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="theme-color" content="#0A0A0A">
    <link rel="canonical" href="https://hoohoo.studio/">
    <!-- Preload background video (if present) for faster, smoother start -->
    <link rel="preload" as="video" href="videos/hoohoo.mp4" type="video/mp4">
</head>
<body>
    <!-- Navigation -->
    <header id="header">
        <div class="container nav-container">
            <a href="#" class="brand">
                <img src="img/owl.svg" alt="Hoo Hoo Studios logo" class="logo">
                <span>Hoo&nbsp;Hoo&nbsp;Studios</span>
            </a>
            <nav class="nav-links">
                <a href="#projects">Projects</a>
                <a href="#about">About</a>
            </nav>
        </div>
    </header>

    <!-- Hero Section -->
    <section id="hero" aria-label="Hoo Hoo Studios hero">
    <!-- Background video - Owl in flight with moonlight -->
    <video
        id="hero-video"
        class="hero-video"
        autoplay
        muted
        playsinline
        preload="auto"
        aria-hidden="true"
    >
        <!--
        ðŸ¦‰ TO ADD YOUR OWL VIDEO:

        OPTION 1 - Quick Setup (Recommended):
        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        1. Visit: https://www.pexels.com/search/videos/owl%20flying/
        2. Find a video you like (look for night/moonlight scenes)
        3. Click "Free Download" and choose "Full HD" or "4K"
        4. Create a folder: videos/
        5. Save the downloaded file as: videos/owl.mp4
        6. Update line below to: <source src="videos/owl.mp4" type="video/mp4" />

        OPTION 2 - Best Free Owl Flying Videos on Pexels:
        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        Search these terms for cinematic owl footage:
        - "owl flying slow motion"
        - "barn owl night"
        - "owl hunting moonlight"
        - "snowy owl flight"

        OPTION 3 - Alternative Free Sources:
        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        - Pixabay: https://pixabay.com/videos/search/owl/
        - Videvo: https://www.videvo.net/stock-video-footage/owl/

        ðŸ’¡ TIPS:
        - Choose videos that are 10-30 seconds long
        - Look for looping footage (similar start/end)
        - Compress large files with HandBrake or FFmpeg
        - Target file size: under 15MB for fast loading

        Current status: Using poster image as placeholder
        -->
        <source src="videos/hoohoo.mp4" type="video/mp4" />
        Your browser does not support the video tag.
    </video>

    

    <!-- Gradient overlay for text readability -->
    <div class="overlay" aria-hidden="true"></div>

    <div class="hero-content" data-scroll-fade>
        <h1 class="hero-title" data-text="Welcome to Hoo&nbsp;Hoo&nbsp;Studios">Welcome to Hoo&nbsp;Hoo&nbsp;Studios</h1>
        <p class="tagline">Owl About that Game.</p>
        <div class="scroll-indicator">
            <span>Scroll to explore</span>
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M12 5v14M19 12l-7 7-7-7"/>
            </svg>
        </div>
    </div>
    </section>

    <!-- Game Advertisement Section -->
    <section id="projects" class="section ad-section grid-section-wrapper" data-scroll-section>
        <canvas id="grid-canvas" class="grid-background"></canvas>
        <div class="container ad-container">
            <div class="ad-text" data-scroll-fade-up>
                <h2>Give a Hoot: Grid Nite!</h2>
                <p>A cozy nightâ€‘owl puzzler with smooth loops and satisfying snaps. Give it a hoot on the App Store.</p>
            </div>
            <div class="ad-badges" data-scroll-fade-up data-delay="100">
                <!-- App Store badge -->
                <a href="https://apps.apple.com/us/app/grid-nite/id6749193485" target="_blank" rel="noopener">
                    <img src="https://developer.apple.com/assets/elements/badges/download-on-the-app-store.svg"
                         alt="Download on the App Store" class="store-badge">
                </a>
                <!-- (Optional) Google Play badge -->
                <!--
                <a href="https://play.google.com/store/apps/details?id=YOUR.GAME.PACKAGE" target="_blank" rel="noopener">
                    <img src="https://upload.wikimedia.org/wikipedia/commons/7/78/Google_Play_Store_badge_EN.svg"
                         alt="Get it on Google Play" class="store-badge">
                </a>
                -->
            </div>
        </div>
    </section>


    <!-- About Section -->
    <section id="about" class="section" data-scroll-section>
        <div class="container content">
            <h2 data-scroll-fade-up>About Us</h2>
            <p data-scroll-fade-up data-delay="100">Hoo are we? A tiny roost of nightâ€‘owls crafting playful little worlds. We ship small, polish hard, and chase that quiet whoaâ€”soft landings, smooth loops, and moments that make you hoot.</p>
        </div>
    </section>

    <!-- Footer -->
    <footer>
        <div class="container footer-content">
            <div class="footer-links">
                <a href="support.html">Support</a>
                <a href="privacy.html">Privacy Policy</a>
                <a href="#about">About</a>
                <a href="mailto:hello@hoohoostudios.com">Contact</a>
            </div>
            <div class="footer-social">
                <a href="https://x.com" target="_blank" rel="noopener" aria-label="X / Twitter">
                    <i class="fa-brands fa-x-twitter"></i>
                </a>
                <a href="https://youtube.com" target="_blank" rel="noopener" aria-label="YouTube">
                    <i class="fa-brands fa-youtube"></i>
                </a>
                <a href="https://discord.com" target="_blank" rel="noopener" aria-label="Discord">
                    <i class="fa-brands fa-discord"></i>
                </a>
            </div>
            <div class="footer-text">
                <p>&copy; 2025 Hoo Hoo Studios. All rights reserved.</p>
            </div>
        </div>
    </footer>

    <!-- Apple-style scroll animations -->
    <script>
        // Structured Data - Organization + WebSite + SoftwareApplication (Grid Nite)
        try {
            const ld = {
              '@context': 'https://schema.org',
              '@graph': [
                {
                  '@type': 'Organization',
                  'name': 'Hoo Hoo Studios',
                  'url': 'https://hoohoo.studio/',
                  'logo': 'https://hoohoo.studio/img/owl.svg',
                  'sameAs': [
                    'https://x.com',
                    'https://youtube.com',
                    'https://discord.com'
                  ],
                  'email': 'mailto:hello@hoohoostudios.com'
                },
                {
                  '@type': 'WebSite',
                  'name': 'Hoo Hoo Studios',
                  'url': 'https://hoohoo.studio/',
                  'potentialAction': {
                    '@type': 'SearchAction',
                    'target': 'https://hoohoo.studio/?q={search_term_string}',
                    'query-input': 'required name=search_term_string'
                  }
                },
                {
                  '@type': 'SoftwareApplication',
                  'name': 'Grid Nite',
                  'operatingSystem': 'iOS',
                  'applicationCategory': 'Game',
                  'offers': { '@type': 'Offer', 'price': '0', 'priceCurrency': 'USD' },
                  'aggregateRating': { '@type': 'AggregateRating', 'ratingValue': '5', 'reviewCount': '12' },
                  'url': 'https://apps.apple.com/us/app/grid-nite/id6749193485'
                }
              ]
            };
            const s = document.createElement('script');
            s.type = 'application/ld+json';
            s.textContent = JSON.stringify(ld);
            document.currentScript.parentNode.insertBefore(s, document.currentScript);
        } catch (e) { /* noop */ }

        // Smooth scroll behavior
        document.addEventListener('DOMContentLoaded', function() {
            // Intersection Observer for scroll-triggered animations
            const observerOptions = {
                threshold: 0.15,
                rootMargin: '0px 0px -100px 0px'
            };

            const observer = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        entry.target.classList.add('visible');
                    }
                });
            }, observerOptions);

            // Observe all elements with scroll animations
            document.querySelectorAll('[data-scroll-fade], [data-scroll-fade-up], [data-scroll-section]').forEach(el => {
                observer.observe(el);
            });

            // Parallax effect for hero video
            let ticking = false;
            const heroVideo = document.getElementById('hero-video');
            const heroContent = document.querySelector('.hero-content');

            window.addEventListener('scroll', () => {
                if (!ticking) {
                    window.requestAnimationFrame(() => {
                        const scrolled = window.pageYOffset;
                        const heroHeight = document.getElementById('hero').offsetHeight;

                        if (scrolled < heroHeight) {
                            // Parallax effect on video
                            if (heroVideo) {
                                heroVideo.style.transform = `translateY(${scrolled * 0.5}px) scale(${1 + scrolled * 0.0002})`;
                            }

                            // Fade out hero content as user scrolls
                            if (heroContent) {
                                const opacity = 1 - (scrolled / (heroHeight * 0.6));
                                const translateY = scrolled * 0.3;
                                heroContent.style.opacity = Math.max(0, opacity);
                                heroContent.style.transform = `translateY(${translateY}px)`;
                            }
                        }

                        ticking = false;
                    });

                    ticking = true;
                }
            });

            // Header transparency on scroll
            const header = document.getElementById('header');
            window.addEventListener('scroll', function() {
                if (window.pageYOffset > 50) {
                    header.classList.add('scrolled');
                } else {
                    header.classList.remove('scrolled');
                }
            }, { passive: true });

            // Hide scroll indicator after scrolling
            window.addEventListener('scroll', function() {
                const scrollIndicator = document.querySelector('.scroll-indicator');
                if (scrollIndicator && window.pageYOffset > 100) {
                    scrollIndicator.style.opacity = '0';
                    scrollIndicator.style.pointerEvents = 'none';
                }
            }, { passive: true });

            // Smooth scroll for anchor links
            document.querySelectorAll('a[href^="#"]').forEach(anchor => {
                anchor.addEventListener('click', function (e) {
                    const href = this.getAttribute('href');
                    if (href !== '#' && href !== '#top') {
                        e.preventDefault();
                        const target = document.querySelector(href);
                        if (target) {
                            const headerOffset = 80;
                            const elementPosition = target.getBoundingClientRect().top;
                            const offsetPosition = elementPosition + window.pageYOffset - headerOffset;

                            window.scrollTo({
                                top: offsetPosition,
                                behavior: 'smooth'
                            });
                        }
                    }
                });
            });

            // Add initial visible state to hero content
            setTimeout(() => {
                heroContent?.classList.add('visible');
            }, 100);

            // Smooth video reveal when it's actually ready
            const hero = document.getElementById('hero');
            const clamp01 = (v) => Math.max(0, Math.min(1, v));
            let fadeRaf;
            let fadeWindow = 2; // seconds; recalculated after metadata

            const syncFadeToTimeline = () => {
                if (!heroVideo || heroVideo.readyState < 1) return;

                const d = heroVideo.duration || 0;
                if (d > 0) {
                    // fadeWindow is 10â€“15% of duration, clamped between 1.0s and 3.0s
                    fadeWindow = Math.max(1.0, Math.min(3.0, d * 0.12));
                }

                const tick = () => {
                    if (!heroVideo) return;
                    const t = heroVideo.currentTime || 0;
                    const dur = heroVideo.duration || 0;
                    let opacity = 1;
                    if (dur > 0) {
                        const fin = clamp01(t / fadeWindow);
                        const fout = clamp01((dur - t) / fadeWindow);
                        opacity = Math.min(fin, fout);
                    }
                    heroVideo.style.opacity = String(opacity);
                    fadeRaf = requestAnimationFrame(tick);
                };

                cancelAnimationFrame(fadeRaf);
                fadeRaf = requestAnimationFrame(tick);
            };

            const revealVideo = () => {
                if (!heroVideo || !hero) return;
                hero.classList.add('video-loaded');
                heroVideo.classList.add('is-loaded');
                // Slow the video to 0.5x for a calm, cinematic feel
                heroVideo.loop = false;
                heroVideo.defaultPlaybackRate = 0.5;
                heroVideo.playbackRate = 0.5;
                syncFadeToTimeline();
            };

            if (heroVideo) {
                // If browser already buffered enough
                if (heroVideo.readyState >= 2) {
                    revealVideo();
                } else {
                    heroVideo.addEventListener('loadedmetadata', revealVideo, { once: true });
                    heroVideo.addEventListener('canplaythrough', revealVideo, { once: true });
                    // Fallback safety after 3s: only reveal if it's actually ready
                    setTimeout(() => {
                        if (!hero.classList.contains('video-loaded') && heroVideo.readyState >= 2) {
                            revealVideo();
                        }
                    }, 3000);
                }

                // In case of error, keep graceful fallback
                heroVideo.addEventListener('error', () => {
                    hero.classList.remove('video-loaded');
                    heroVideo.classList.remove('is-loaded');
                }, { once: true });

                // Keep 0.5x playback and fade sync on play/seek/loop
                heroVideo.addEventListener('play', () => {
                    heroVideo.playbackRate = 0.5;
                    syncFadeToTimeline();
                });
                heroVideo.addEventListener('seeking', () => {
                    syncFadeToTimeline();
                });
                heroVideo.addEventListener('loadedmetadata', () => {
                    heroVideo.defaultPlaybackRate = 0.5;
                });

                // Pause at end, wait 3s, then restart from 0
                let loopTimeout;
                const scheduleLoopRestart = () => {
                    clearTimeout(loopTimeout);
                    loopTimeout = setTimeout(() => {
                        if (!heroVideo) return;
                        try { heroVideo.currentTime = 0; } catch (e) {}
                        heroVideo.playbackRate = 0.5;
                        const p = heroVideo.play();
                        if (p && typeof p.then === 'function') p.catch(() => {});
                    }, 3000);
                };

                heroVideo.addEventListener('ended', () => {
                    try { heroVideo.pause(); } catch (e) {}
                    cancelAnimationFrame(fadeRaf);
                    heroVideo.style.opacity = '0';
                    scheduleLoopRestart();
                });
            }

            // Grid Nite animated background - "Lights Out" style
            const canvas = document.getElementById('grid-canvas');
            const adSection = document.querySelector('.ad-section');

            if (canvas && adSection) {
                const ctx = canvas.getContext('2d');
                let animationId;

                // Grid configuration - maintain square aspect ratio
                const gridSize = 60; // Size of each cell in pixels
                let cols, rows;

                function calculateGridDimensions() {
                    const adRect = adSection.getBoundingClientRect();
                    const adHeight = Math.max(adRect.height, adSection.scrollHeight);

                    // Add extra cells to ensure full coverage even with gaps
                    cols = Math.ceil(adRect.width / gridSize) + 2;
                    rows = Math.ceil(adHeight / gridSize) + 2;
                }

                calculateGridDimensions();

                // Initialize grid state (0 = off, 1 = on) with 50% entropy
                let grid = Array(rows).fill().map(() =>
                    Array(cols).fill().map(() => Math.random() > 0.5 ? 1 : 0)
                );
                let targetGrid = Array(rows).fill().map(() =>
                    Array(cols).fill().map(() => Math.random() > 0.5 ? 1 : 0)
                );
                // Track flash state for transition effect
                let flashGrid = Array(rows).fill().map(() => Array(cols).fill(0));

                // Resize canvas - set internal resolution to match display size
                function resizeCanvas() {
                    const adRect = adSection.getBoundingClientRect();
                    const adHeight = Math.max(adRect.height, adSection.scrollHeight);

                    // Store old dimensions
                    const oldRows = rows;
                    const oldCols = cols;

                    // Set canvas internal resolution to match CSS size
                    canvas.width = adRect.width;
                    canvas.height = adHeight;
                    // No CSS scaling needed - 1:1 pixel mapping
                    canvas.style.width = adRect.width + 'px';
                    canvas.style.height = adHeight + 'px';

                    // Recalculate grid dimensions with new height
                    calculateGridDimensions();

                    // Reinitialize grids if dimensions changed
                    if (rows !== oldRows || cols !== oldCols) {
                        grid = Array(rows).fill().map(() =>
                            Array(cols).fill().map(() => Math.random() > 0.5 ? 1 : 0)
                        );
                        targetGrid = Array(rows).fill().map(() =>
                            Array(cols).fill().map(() => Math.random() > 0.5 ? 1 : 0)
                        );
                        flashGrid = Array(rows).fill().map(() => Array(cols).fill(0));
                    }
                }
                resizeCanvas();

                // Toggle cell and neighbors (Lights Out pattern)
                function toggleCell(row, col) {
                    const positions = [
                        [row, col],       // center
                        [row - 1, col],   // top
                        [row + 1, col],   // bottom
                        [row, col - 1],   // left
                        [row, col + 1]    // right
                    ];

                    positions.forEach(([r, c]) => {
                        if (r >= 0 && r < rows && c >= 0 && c < cols) {
                            targetGrid[r][c] = 1 - targetGrid[r][c]; // Toggle
                            flashGrid[r][c] = 1; // Trigger flash effect
                        }
                    });
                }

                // Randomly trigger toggles for organic animation
                function randomToggle() {
                    const row = Math.floor(Math.random() * rows);
                    const col = Math.floor(Math.random() * cols);
                    toggleCell(row, col);
                }

                // Smooth interpolation between current and target state
                function updateGrid() {
                    for (let r = 0; r < rows; r++) {
                        // Safety check for array bounds
                        if (!grid[r] || !targetGrid[r] || !flashGrid[r]) continue;

                        for (let c = 0; c < cols; c++) {
                            // Safety check for array bounds
                            if (grid[r][c] === undefined || targetGrid[r][c] === undefined) continue;

                            const diff = targetGrid[r][c] - grid[r][c];
                            grid[r][c] += diff * 0.05; // Smooth transition

                            // Decay flash effect slowly
                            if (flashGrid[r][c] > 0) {
                                flashGrid[r][c] -= 0.02; // Slow fade
                                if (flashGrid[r][c] < 0) flashGrid[r][c] = 0;
                            }
                        }
                    }
                }

                // Draw the grid with rounded corners and uniform angled gradient
                let cachedGradient = null;
                let lastCanvasWidth = 0;
                let lastCanvasHeight = 0;

                function drawGrid() {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);

                    const gap = 2;
                    const radius = 8;

                    // Cache gradient if canvas size hasn't changed
                    if (!cachedGradient || lastCanvasWidth !== canvas.width || lastCanvasHeight !== canvas.height) {
                        cachedGradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
                        cachedGradient.addColorStop(0, 'rgba(255, 70, 85, 0.35)');
                        cachedGradient.addColorStop(0.5, 'rgba(255, 70, 85, 0.25)');
                        cachedGradient.addColorStop(1, 'rgba(255, 70, 85, 0.15)');
                        lastCanvasWidth = canvas.width;
                        lastCanvasHeight = canvas.height;
                    }

                    // Draw all active squares as masks for the gradient
                    for (let r = 0; r < rows; r++) {
                        // Safety check for array bounds
                        if (!grid[r] || !flashGrid[r]) continue;

                        for (let c = 0; c < cols; c++) {
                            // Safety check for array bounds
                            if (grid[r][c] === undefined) continue;

                            const opacity = grid[r][c];
                            const flash = flashGrid[r][c];

                            if (opacity > 0.01 || flash > 0.01) {
                                // Calculate position - use gridSize directly (60px)
                                const x = c * gridSize + gap;
                                const y = r * gridSize + gap;
                                const size = gridSize - gap * 2; // 56px square

                                // Combine opacity with flash (flash adds brightness)
                                const finalOpacity = Math.min(1, opacity + flash * 0.6);
                                ctx.globalAlpha = finalOpacity;

                                // Draw filled rounded SQUARE (width = height = size)
                                // Use brighter color when flashing
                                if (flash > 0.1) {
                                    // Flash with bright white-ish red
                                    const flashColor = `rgba(255, ${100 + Math.floor(flash * 155)}, ${100 + Math.floor(flash * 155)}, 1)`;
                                    ctx.fillStyle = flashColor;
                                } else {
                                    ctx.fillStyle = cachedGradient;
                                }

                                ctx.beginPath();
                                ctx.roundRect(x, y, size, size, radius);
                                ctx.fill();

                                // Draw subtle border (only if needed for performance)
                                if (finalOpacity > 0.05) {
                                    ctx.strokeStyle = flash > 0.1 ? 'rgba(255, 255, 255, 0.4)' : 'rgba(255, 70, 85, 0.2)';
                                    ctx.lineWidth = 1;
                                    ctx.beginPath();
                                    ctx.roundRect(x, y, size, size, radius);
                                    ctx.stroke();
                                }
                            }
                        }
                    }

                    // Reset global alpha
                    ctx.globalAlpha = 1;
                }

                // Animation loop
                let lastToggle = 0;
                function animate(timestamp) {
                    // Trigger random toggles every 800-1500ms
                    if (timestamp - lastToggle > 800 + Math.random() * 700) {
                        randomToggle();
                        lastToggle = timestamp;
                    }

                    updateGrid();
                    drawGrid();
                    animationId = requestAnimationFrame(animate);
                }

                // Start animation when section is in view
                const observer = new IntersectionObserver((entries) => {
                    entries.forEach(entry => {
                        if (entry.isIntersecting) {
                            if (!animationId) animate(0);
                        } else {
                            if (animationId) {
                                cancelAnimationFrame(animationId);
                                animationId = null;
                            }
                        }
                    });
                }, { threshold: 0.1 });

                observer.observe(adSection);

                // Handle window resize with debounce for efficiency
                let resizeTimeout;
                window.addEventListener('resize', () => {
                    clearTimeout(resizeTimeout);
                    resizeTimeout = setTimeout(() => {
                        resizeCanvas();
                    }, 150); // Debounce resize events
                }, { passive: true });
            }
        });
    </script>
</body>
</html>
